// Copyright 2019 The Cloud Robotics Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// grpc2rest contains methods for converting Kubernetes-style REST to gRPC.
//
// It contains a Method class that has all request-time information, and
// a ResourceInfoRepository class responsible for creating Method instances.
package grpc2rest

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/dynamic"
	crdtypes "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
)

// Request is an interface for the subset of k8s.io/client-go/rest.Request
// that this code uses. The semantics are the same as rest.Request and repeated
// below because rest.Request is poorly documented.
type Request interface {
	// DoRaw returns a body with a single JSON message of the message's
	// GetOutputMessage() type on success. On error, body may contain JSON
	// with an instance of k8s.io/apimachinery/pkg/apis/meta/v1.Status.
	DoRaw(context.Context) ([]byte, error)
	// Stream returns a stream with JSON messages. Each message is a
	// k8s.io/apimachinery/pkg/apis/meta/v1.WatchEvent instance. The object
	// in the WatchEvent may either be a regular object (in which case the
	// GetOutputMessage() can parse the entire JSON), or an meta/v1.Status.
	Stream(context.Context) (io.ReadCloser, error)
}

// Method abstracts the semantics of a Kubernetes gRPC method.
type Method interface {
	// GetInputMessage returns the proto message for gRPC input.
	// e.g. GetHelloWorldRequest for K8sHelloWorld.Get.
	GetInputMessage() proto.Message
	// GetOutputMessage returns the proto message for gRPC output.
	// e.g. HelloWorld for K8sHelloWorld.Get.
	GetOutputMessage() proto.Message
	// BuildKubernetesRequest builds a HTTP request for the gRPC input.
	// Must be passed a message generated by GetInputMessage.
	BuildKubernetesRequest(proto.Message) (Request, error)
	// IsWatchCall returns true if the call is a Kubernetes Watch call.
	// Watch calls must be read with Stream() instead of DoRaw() and may
	// return objects that can't be parsed by GetOutputMessage().
	IsWatchCall() bool
}

func buildMethods(obj *crdtypes.CustomResourceDefinition, config *rest.Config) (map[string]Method, error) {
	// Ignore resource without proto descriptors
	if obj.ObjectMeta.Annotations["crc.cloudrobotics.com/proto-descriptor"] == "" {
		return map[string]Method{}, nil
	}

	fd, err := getFileDescriptor(obj)
	if err != nil {
		return nil, err
	}
	svc, err := getService(fd, obj.Spec.Names.Kind)
	if err != nil {
		return nil, err
	}

	if len(obj.Spec.Versions) != 1 {
		return nil, fmt.Errorf("ignoring CRD %s with multiple versions", obj.ObjectMeta.Name)
	}
	version := obj.Spec.Versions[0].Name

	c := *config
	c.APIPath = "/apis"
	c.GroupVersion = &schema.GroupVersion{obj.Spec.Group, version}
	c.NegotiatedSerializer = serializer.WithoutConversionCodecFactory{CodecFactory: scheme.Codecs}

	// Build Kubernetes REST client.
	client, err := rest.RESTClientFor(&c)
	if err != nil {
		return nil, fmt.Errorf("error building Kubernetes client: %v", err)
	}

	methods := make(map[string]Method)
	for _, method := range svc.GetMethods() {
		requestParams, err := createRequestParams(method.GetName())
		if err != nil {
			return nil, fmt.Errorf("unrecognized method for %s: %v", method.GetName(), err)
		}
		requestParams.inMessage = dynamic.NewMessage(method.GetInputType())
		requestParams.outMessage = dynamic.NewMessage(method.GetOutputType())
		requestParams.apiVersion = c.GroupVersion.String()
		requestParams.kind = obj.Spec.Names.Kind
		requestParams.kindPlural = obj.Spec.Names.Plural
		requestParams.client = client
		requestParams.isNamespacedResource = (obj.Spec.Scope == crdtypes.NamespaceScoped)
		grpcPath := fmt.Sprintf("/%s/%s", svc.GetFullyQualifiedName(), method.GetName())
		methods[grpcPath] = requestParams
	}

	return methods, nil
}

func createRequestParams(method string) (*k8sRequestParams, error) {
	var params *k8sRequestParams

	switch method {
	case "Get":
		params = &k8sRequestParams{
			verb:                 "GET",
			optionsAsQueryParams: true,
			setWatchParam:        false,
			nameInPath:           true,
			namePath:             "name",
			setKindAndApiGroup:   false,
			namespacePath:        "namespace",
			namespaceDefaults:    true,
			isWatch:              false,
			bodyFieldName:        "",
		}
	case "List":
		params = &k8sRequestParams{
			verb:                 "GET",
			optionsAsQueryParams: true,
			setWatchParam:        true,
			watchParamValue:      false,
			nameInPath:           false,
			setKindAndApiGroup:   false,
			namespacePath:        "namespace",
			namespaceDefaults:    false,
			isWatch:              false,
			bodyFieldName:        "",
		}
	case "Watch":
		params = &k8sRequestParams{
			verb:                 "GET",
			optionsAsQueryParams: true,
			setWatchParam:        true,
			watchParamValue:      true,
			nameInPath:           false,
			setKindAndApiGroup:   false,
			namespacePath:        "namespace",
			namespaceDefaults:    false,
			isWatch:              true,
			bodyFieldName:        "",
		}
	case "Create":
		params = &k8sRequestParams{
			verb:                 "POST",
			optionsAsQueryParams: true,
			setWatchParam:        false,
			nameInPath:           false,
			setKindAndApiGroup:   true,
			namespacePath:        "object.metadata.namespace",
			namespaceDefaults:    true,
			isWatch:              false,
			bodyFieldName:        "object",
		}
	case "Update":
		params = &k8sRequestParams{
			verb:                 "PUT",
			optionsAsQueryParams: true,
			setWatchParam:        false,
			nameInPath:           true,
			namePath:             "object.metadata.name",
			setKindAndApiGroup:   true,
			namespacePath:        "object.metadata.namespace",
			namespaceDefaults:    true,
			isWatch:              false,
			bodyFieldName:        "object",
		}
	case "UpdateStatus":
		return nil, errors.New("UpdateStatus is not yet implemented")
	case "Delete":
		params = &k8sRequestParams{
			verb:                 "DELETE",
			optionsAsQueryParams: false,
			setWatchParam:        false,
			nameInPath:           true,
			namePath:             "name",
			setKindAndApiGroup:   false,
			namespacePath:        "namespace",
			namespaceDefaults:    true,
			isWatch:              false,
			bodyFieldName:        "options",
		}
	default:
		return nil, fmt.Errorf("unsupported method: %v", method)
	}
	return params, nil
}

func getFileDescriptor(obj *crdtypes.CustomResourceDefinition) (*desc.FileDescriptor, error) {
	annotation := obj.ObjectMeta.Annotations["crc.cloudrobotics.com/proto-descriptor"]
	if annotation == "" {
		return nil, fmt.Errorf("no proto-descriptor annotation on %s", obj.ObjectMeta.Name)
	}
	b, err := base64.StdEncoding.DecodeString(annotation)
	if err != nil {
		return nil, fmt.Errorf("unable to decode base64 in proto-descriptor annotation on %s: %v", obj.ObjectMeta.Name, err)
	}
	// Unmarshal file descriptor set.
	fds := &descriptor.FileDescriptorSet{}
	if err := proto.Unmarshal(b, fds); err != nil {
		return nil, fmt.Errorf("unable to unmarshal FileDescriptorSet from proto-descriptor annotation on %s: %v", obj.ObjectMeta.Name, err)
	}

	// Create dynamic file descriptor.
	fd, err := desc.CreateFileDescriptorFromSet(fds)
	if err != nil {
		return nil, err
	}

	return fd, nil
}

func getService(fd *desc.FileDescriptor, kind string) (*desc.ServiceDescriptor, error) {
	// Determine kind and kindPlural.
	serviceName := fmt.Sprintf("K8s%s", kind)
	svcs := fd.GetServices()
	for _, svc := range svcs {
		if svc.GetName() == serviceName {
			return svc, nil
		}
	}
	return nil, fmt.Errorf("no service with name %s found in proto descriptor for %s", serviceName, kind)
}

type k8sRequestParams struct {
	inMessage            proto.Message
	outMessage           proto.Message
	verb                 string // HTTP verb for REST ("POST")
	optionsAsQueryParams bool   // copy options from proto to ? URL params
	setWatchParam        bool   // force ?watch to watchParamValue
	watchParamValue      bool   // forced value of watchParam
	nameInPath           bool   // put the resource's name into the URL path
	namePath             string // proto path (a.b.c) to the name field
	setKindAndApiGroup   bool   // override kind/apiVersion in object field
	namespacePath        string // proto path (a.b.c) to the namespace field
	namespaceDefaults    bool   // whether empty namespace is "default" (true) or all namespaces (false)
	isWatch              bool   // whether the response is streaming
	isNamespacedResource bool   // whether this resource is namespaced (vs cluster-scoped)
	bodyFieldName        string // name of the field that goes into the body
	kind                 string // camel-case Kind ("HelloWorld")
	kindPlural           string // lower-case plural of Kind ("helloworlds")
	apiVersion           string // apiVersion including group ("foo.com/v1")
	client               rest.Interface
}

func (params *k8sRequestParams) GetInputMessage() proto.Message {
	return proto.Clone(params.inMessage)
}

func (params *k8sRequestParams) GetOutputMessage() proto.Message {
	return proto.Clone(params.outMessage)
}

func (params *k8sRequestParams) BuildKubernetesRequest(msg proto.Message) (Request, error) {
	inMessage := msg.(*dynamic.Message)

	// Add Kind and ApiGroup if necessary.
	if params.setKindAndApiGroup {
		objectInterface, err := inMessage.TryGetFieldByName("object")
		if err != nil {
			return nil, errors.New("missing field: 'object'")
		}
		object, ok := objectInterface.(*dynamic.Message)
		if !ok {
			return nil, errors.New("object is not a message")
		}
		if err := object.TrySetFieldByName("kind", params.kind); err != nil {
			return nil, errors.New("object has no 'kind' field")
		}
		if err := object.TrySetFieldByName("apiVersion", params.apiVersion); err != nil {
			return nil, errors.New("object has no 'apiVersion' field")
		}
	}

	// Create Kubernetes request.
	req := params.client.Verb(params.verb).Resource(params.kindPlural)
	if params.isNamespacedResource {
		namespace, err := getStringField(params.namespacePath, inMessage)
		if err != nil {
			return nil, fmt.Errorf("unable to determine namespace: %v", err)
		}
		if params.namespaceDefaults && namespace == "" {
			namespace = "default"
		}
		req = req.Namespace(namespace)
	}
	// Set resource name.
	if params.nameInPath {
		name, err := getStringField(params.namePath, inMessage)
		if err != nil {
			return nil, fmt.Errorf("unable to determine resource name: %v", err)
		}
		if name == "" {
			return nil, fmt.Errorf("empty name is not allowed for this method")
		}
		req = req.Name(name)
	}
	// Set query params.
	if params.setWatchParam {
		optionsInterface, err := inMessage.TryGetFieldByName("options")
		if err != nil {
			return nil, errors.New("unknown field: options")
		}
		options, ok := optionsInterface.(*dynamic.Message)
		if !ok {
			return nil, errors.New("options is not a message")
		}
		if params.watchParamValue {
			if err := options.TrySetFieldByName("watch", params.watchParamValue); err != nil {
				return nil, errors.New("options has no watch parameter")
			}
		} else {
			if err := options.TryClearFieldByName("watch"); err != nil {
				return nil, errors.New("options has no watch parameter")
			}
		}
	}
	if params.optionsAsQueryParams {
		queryParams, err := getQueryParams(inMessage)
		if err != nil {
			return nil, fmt.Errorf("error determining query parameters: %v", err)
		}
		for k, v := range queryParams {
			req = req.Param(k, v)
		}
	}
	// Set body.
	if params.bodyFieldName != "" {
		body, err := getBody(inMessage, params.bodyFieldName)
		if err != nil {
			return nil, fmt.Errorf("unable to create request body: %v", err)
		}
		req = req.Body(body)
	}

	return req, nil
}

func (params *k8sRequestParams) IsWatchCall() bool {
	return params.isWatch
}

func getStringField(path string, msg *dynamic.Message) (string, error) {
	var (
		field interface{}
		err   error
		ok    bool
	)
	parts := strings.Split(path, ".")
	submsg := msg
	for i, p := range parts {
		field, err = submsg.TryGetFieldByName(p)
		if err != nil {
			return "", fmt.Errorf("unable to find field %q in %s", strings.Join(parts[0:i+1], "."), proto.MessageName(msg))
		}
		if i < len(parts)-1 {
			submsg, ok = field.(*dynamic.Message)
			if !ok {
				return "", fmt.Errorf("field %q of %s is not a message", strings.Join(parts[0:i+1], "."), proto.MessageName(msg))
			}
		}
	}
	result, ok := field.(string)
	if !ok {
		return "", fmt.Errorf("field %q of %s is not a string", path, proto.MessageName(msg))
	}
	return result, nil
}

func getBody(message *dynamic.Message, fieldName string) ([]byte, error) {
	obj, err := message.TryGetFieldByName(fieldName)
	if err != nil {
		return nil, fmt.Errorf("unable to extract field %q: %v", fieldName, err)
	}
	bodyMessage, ok := obj.(*dynamic.Message)
	if !ok {
		return nil, fmt.Errorf("%q is not a message", fieldName)
	}
	body, err := bodyMessage.MarshalJSON()
	if err != nil {
		return nil, fmt.Errorf("unable to marshal body message to JSON: %v", err)
	}
	return body, nil
}

func getQueryParams(message *dynamic.Message) (map[string]string, error) {
	optionsInterface, err := message.TryGetFieldByName("options")
	if err != nil {
		return nil, errors.New("unknown field: options")
	}
	options, ok := optionsInterface.(*dynamic.Message)
	if !ok {
		return nil, errors.New("options is not a message")
	}
	queryParams := make(map[string]string)
	if options != nil {
		optionFields := options.GetKnownFields()
		for _, f := range optionFields {
			if options.HasField(f) {
				optionName := f.GetName()
				optionType := f.GetType()
				optionValueInterface := options.GetField(f)
				var optionValue string
				ok = false
				switch optionType {
				case descriptor.FieldDescriptorProto_TYPE_STRING:
					// TODO(daschmidt): Do we need to handle repeated string fields?
					// (Case in point: UpdateOptions.dryRun)
					optionValue, ok = optionValueInterface.(string)
				case descriptor.FieldDescriptorProto_TYPE_INT64:
					var optionValueInt64 int64
					optionValueInt64, ok = optionValueInterface.(int64)
					optionValue = strconv.FormatInt(optionValueInt64, 10)
				case descriptor.FieldDescriptorProto_TYPE_BOOL:
					var optionValueBool bool
					optionValueBool, ok = optionValueInterface.(bool)
					optionValue = strconv.FormatBool(optionValueBool)
				}
				if ok {
					queryParams[optionName] = optionValue
				} else {
					log.Printf("unable to process option field %s.", optionName)
				}
			}
		}
	}
	return queryParams, nil
}
