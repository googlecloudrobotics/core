load("@io_bazel_rules_docker//container:providers.bzl", "ImageInfo", "ImportInfo")
load("//bazel:build_rules/helm_chart.bzl", "helm_chart")
load("//bazel/build_rules/app_chart:cache_gcr_credentials.bzl", "cache_gcr_credentials")
load("//bazel/build_rules/app_chart:push_all.bzl", "push_all")

# Simplified version of _assemble_image_digest found in
# https://github.com/bazelbuild/rules_docker/blob/master/container/image.bzl
# This function executes digester to find the Docker image's digest.
def _assemble_image_digest(ctx, image, output_digest):
    output_digest_arg = "--dst=%s" % output_digest.path
    tarball_arg = "--tarball=%s" % image.path
    arguments = [tarball_arg, output_digest_arg]
    ctx.actions.run(
        outputs = [output_digest],
        inputs = [image],
        tools = ([image["legacy"]] if image.get("legacy") else []),
        executable = ctx.executable._digester,
        arguments = arguments,
        mnemonic = "ImageDigest",
        progress_message = "Extracting image digest",
    )

def _impl(ctx):
    chart_yaml = ctx.actions.declare_file(ctx.label.name + "-chart.yaml")

    ctx.actions.expand_template(
        template = ctx.file._chart_yaml_template,
        output = chart_yaml,
        substitutions = {"${name}": ctx.label.name, "${version}": "0.0.1"},
    )

    values_yaml = ctx.actions.declare_file(ctx.label.name + "-values.yaml")
    source_digests = []
    cmds = [
        "cat {} - > {} <<EOF".format(ctx.file.values.path, values_yaml.path),
        "### Generated by app_chart ###",
        "images:",
    ]
    images = ctx.attr.images or {}
    for key, value in images.items():
        digest_file = None
        if ImageInfo in key:
            digest_file = key[ImageInfo].container_parts["digest"]
        else:
            # container_pull/container_image rules don't export ImageInfo.
            digest_file = ctx.actions.declare_file("{}-{}-digest".format(ctx.label.name, value))
            _assemble_image_digest(ctx, key[ImportInfo].container_parts, digest_file)

        # keep the leading '/' since helm charts prepend the registry without one
        cmds.append("  {nick}: /{image}@$(cat {digest})".format(
            nick = value.replace("-", "_"),
            image = value,
            digest = digest_file.path,
        ))
        source_digests.append(digest_file)
    cmds.append("EOF")

    ctx.actions.run_shell(
        outputs = [values_yaml],
        inputs = ctx.files.values + source_digests,
        command = "\n".join(cmds),
    )

    helm_chart(
        ctx,
        name = ctx.label.name,
        chart = chart_yaml,
        values = values_yaml,
        # TODO(b/72936439): This is currently unused and fixed to 0.0.1.
        version = "0.0.1",
        templates = ctx.files.templates,
        files = ctx.files.files,
        helm = ctx.file._helm,
        out = ctx.outputs.chart,
    )

    return [DefaultInfo(
        runfiles = ctx.runfiles(files = [ctx.outputs.chart]),
        files = depset([ctx.outputs.chart]),
    )]

_app_chart_backend = rule(
    implementation = _impl,
    attrs = {
        "chart": attr.string(
            doc = "the chart name (robot/cloud/cloud-per-robot)",
            mandatory = True,
        ),
        "values": attr.label(
            allow_single_file = True,
            doc = "The values.yaml file.",
        ),
        "templates": attr.label_list(
            allow_empty = True,
            allow_files = True,
            default = [],
            doc = "Files for the chart's templates/ directory.",
        ),
        "files": attr.label_list(
            allow_empty = True,
            allow_files = True,
            default = [],
            doc = "Extra non-template files for the chart's files/ directory.",
        ),
        "images": attr.label_keyed_string_dict(
            allow_empty = True,
            doc = "Images referenced by the chart.",
        ),
        "_chart_yaml_template": attr.label(
            default = Label("@cloud_robotics//bazel/build_rules/app_chart:Chart.yaml.template"),
            allow_single_file = True,
        ),
        "_helm": attr.label(
            default = Label("@kubernetes_helm//:helm"),
            allow_single_file = True,
        ),
        "_digester": attr.label(
            default = "@io_bazel_rules_docker//container/go/cmd/digester:digester",
            cfg = "exec",
            executable = True,
        ),
    },
    outputs = {
        "chart": "%{name}-0.0.1.tgz",
    },
)

def app_chart(
        name,
        values = None,
        extra_templates = None,
        files = None,
        images = None,
        visibility = None):
    """Macro for a standard Cloud Robotics helm chart.

    This macro establishes two subrules for chart name "foo-cloud":
    - :foo-cloud.push pushes the Docker images for the chart (if relevant).
    - :foo-cloud.snippet-yaml is a snippet of YAML defining the chart, which is
      used by app() to generate an App CR containing multiple inline
      charts.

    Args:
      name: string. Must be in the format {app}-{chart}, where chart is
        robot, cloud, or cloud-per-robot.
      values: file. The values.yaml file.
      extra_templates: list of files. Extra files for the chart's templates/ directory.
      files: list of files. Extra non-template files for the chart's files/ directory.
      images: dict. Images referenced by the chart.
      visibility: Visibility.
    """

    _, chart = name.rsplit("-", 1)
    if name.endswith("cloud-per-robot"):
        chart = "cloud-per-robot"

    if not values:
        if chart == "cloud":
            values = "@cloud_robotics//bazel/build_rules/app_chart:values-cloud.yaml"
        else:
            values = "@cloud_robotics//bazel/build_rules/app_chart:values-robot.yaml"

    # We have a dict of string:target, but bazel rules only support target:string.
    reversed_images = {}
    if images:
        for k, v in images.items():
            reversed_images[v] = k

    _app_chart_backend(
        name = name,
        chart = chart,
        values = values,
        templates = native.glob([chart + "/*.yaml"], allow_empty = True) + (extra_templates or []),
        files = files,
        images = reversed_images,
        visibility = visibility,
    )

    push_all(
        name = name + ".push-all-containers",
        images = images,
    )

    cache_gcr_credentials(
        name = name + ".push",
        target = name + ".push-all-containers",
        visibility = visibility,
    )

    native.genrule(
        name = name + ".snippet-yaml",
        srcs = [name],
        outs = [name + ".snippet.yaml"],
        cmd = """cat <<EOF > $@
    {target}:
      inline: $$(base64 -w 0 $<)
EOF
""".format(name = name, target = chart),
    )
