load("//bazel:build_rules/helm_chart.bzl", "helm_chart")
load("//bazel/build_rules/app_chart:cache_gcr_credentials.bzl", "cache_gcr_credentials")
load("//bazel/build_rules/app_chart:push_all.bzl", "push_all")

def _impl(ctx):
    chart_yaml = ctx.actions.declare_file(ctx.label.name + "-chart.yaml")

    ctx.actions.expand_template(
        template = ctx.file._chart_yaml_template,
        output = chart_yaml,
        substitutions = {"${name}": ctx.label.name, "${version}": "0.0.1"},
    )

    values_yaml = ctx.actions.declare_file(ctx.label.name + "-values.yaml")
    source_digests = []
    cmds = [
        "cat {} - > {} <<EOF".format(ctx.file.values.path, values_yaml.path),
        "### Generated by app_chart ###",
        "images:",
    ]
    jq_bin = ctx.toolchains["@aspect_bazel_lib//lib:jq_toolchain_type"].jqinfo.bin

    images = ctx.attr.images or {}
    for key, value in images.items():
        key_files = key[DefaultInfo].files
        for file in key_files.to_list():
            image_dir = file

        # keep the leading '/' since helm charts prepend the registry without one
        cmds.append("  {nick}: /{image}@$({jq} -r '.manifests[0].digest' {digest}/index.json)".format(
            nick = value.replace("-", "_"),
            image = value,
            digest = image_dir.path,
            jq = jq_bin.path,
        ))
        source_digests.append(image_dir)
    cmds.append("EOF")

    ctx.actions.run_shell(
        tools = [jq_bin],
        outputs = [values_yaml],
        inputs = ctx.files.values + source_digests,
        command = "\n".join(cmds),
    )

    helm_chart(
        ctx,
        name = ctx.label.name,
        chart = chart_yaml,
        values = values_yaml,
        # TODO(b/72936439): This is currently unused and fixed to 0.0.1.
        version = "0.0.1",
        templates = ctx.files.templates,
        files = ctx.files.files,
        helm = ctx.file._helm,
        out = ctx.outputs.chart,
    )

    return [DefaultInfo(
        runfiles = ctx.runfiles(files = [ctx.outputs.chart]),
        files = depset([ctx.outputs.chart]),
    )]

_app_chart_backend = rule(
    implementation = _impl,
    attrs = {
        "chart": attr.string(
            doc = "the chart name (robot/cloud/cloud-per-robot)",
            mandatory = True,
        ),
        "values": attr.label(
            allow_single_file = True,
            doc = "The values.yaml file.",
        ),
        "templates": attr.label_list(
            allow_empty = True,
            allow_files = True,
            default = [],
            doc = "Files for the chart's templates/ directory.",
        ),
        "files": attr.label_list(
            allow_empty = True,
            allow_files = True,
            default = [],
            doc = "Extra non-template files for the chart's files/ directory.",
        ),
        "images": attr.label_keyed_string_dict(
            allow_empty = True,
            doc = "Images referenced by the chart.",
        ),
        "_chart_yaml_template": attr.label(
            default = Label("@cloud_robotics//bazel/build_rules/app_chart:Chart.yaml.template"),
            allow_single_file = True,
        ),
        "_helm": attr.label(
            default = Label("@kubernetes_helm//:helm"),
            allow_single_file = True,
        ),
    },
    outputs = {
        "chart": "%{name}-0.0.1.tgz",
    },
    toolchains = ["@aspect_bazel_lib//lib:jq_toolchain_type"],
)

def app_chart(
        name,
        values = None,
        extra_templates = None,
        files = None,
        images = None,
        visibility = None):
    """Macro for a standard Cloud Robotics helm chart.

    This macro establishes two subrules for chart name "foo-cloud":
    - :foo-cloud.push pushes the Docker images for the chart (if relevant).
    - :foo-cloud.snippet-yaml is a snippet of YAML defining the chart, which is
      used by app() to generate an App CR containing multiple inline
      charts.

    Args:
      name: string. Must be in the format {app}-{chart}, where chart is
        robot, cloud, or cloud-per-robot.
      values: file. The values.yaml file.
      extra_templates: list of files. Extra files for the chart's templates/ directory.
      files: list of files. Extra non-template files for the chart's files/ directory.
      images: dict. Images referenced by the chart.
      visibility: Visibility.
    """

    _, chart = name.rsplit("-", 1)
    if name.endswith("cloud-per-robot"):
        chart = "cloud-per-robot"

    if not values:
        if chart == "cloud":
            values = "@cloud_robotics//bazel/build_rules/app_chart:values-cloud.yaml"
        else:
            values = "@cloud_robotics//bazel/build_rules/app_chart:values-robot.yaml"

    # We have a dict of string:target, but bazel rules only support target:string.
    reversed_images = {}
    if images:
        for k, v in images.items():
            reversed_images[v] = k

    _app_chart_backend(
        name = name,
        chart = chart,
        values = values,
        templates = native.glob([chart + "/*.yaml"], allow_empty = True) + (extra_templates or []),
        files = files,
        images = reversed_images,
        visibility = visibility,
    )

    push_all(
        name = name + ".push-all-containers",
        images = images,
    )

    cache_gcr_credentials(
        name = name + ".push",
        target = name + ".push-all-containers",
        visibility = visibility,
    )

    native.genrule(
        name = name + ".snippet-yaml",
        srcs = [name],
        outs = [name + ".snippet.yaml"],
        cmd = """cat <<EOF > $@
    {target}:
      inline: $$(base64 -w 0 $<)
EOF
""".format(name = name, target = chart),
    )
